
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>eventbus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/krateoplatformops/krateo/pkg/eventbus/eventbus.go (100.0%)</option>
				
				<option value="file1">github.com/krateoplatformops/krateo/pkg/storage/local/local.go (58.7%)</option>
				
				<option value="file2">github.com/krateoplatformops/krateo/pkg/strvals/parser.go (92.5%)</option>
				
				<option value="file3">github.com/krateoplatformops/krateo/pkg/xrds/parser.go (83.7%)</option>
				
				<option value="file4">github.com/krateoplatformops/krateo/pkg/xrds/types_jsonschema.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package eventbus provides event publisher/subscriber support.
// It's inspired by https://github.com/asaskevich/EventBus
// There are differences in API and implementation
//  - deadlock prevention: this eventbus doesn't lock mutex when callbacks are called
//  - API based on EventID and Event interface instead of strings and variadic arguments list

package eventbus

import (
        "sync"
)

// EventID identifies events topic.
type EventID string

// Event must be implemented by anything that can be published
type Event interface {
        EventID() EventID
}

// EventHandler is function that can be subscribed to the event
type EventHandler func(event Event)

// Subscription represents active event subscription
type Subscription struct {
        eventID EventID
        id      uint64
}

// BusSubscriber allows to subscribe/unsubscribe own event handlers
type BusSubscriber interface {
        Subscribe(eventID EventID, cb EventHandler) Subscription
        Unsubscribe(id Subscription)
}

// BusPublisher allows to publish own events
type BusPublisher interface {
        Publish(event Event)
}

// Bus allows to subscribe/unsubscribe to external events and publish own events
type Bus interface {
        BusSubscriber
        BusPublisher
}

// New returns new event bus
func New() Bus <span class="cov6" title="5">{
        b := &amp;bus{
                infos: make(map[EventID]subscriptionInfoList),
        }
        return b
}</span>

type subscriptionInfo struct {
        id uint64
        cb EventHandler
}

type subscriptionInfoList []*subscriptionInfo

type bus struct {
        lock   sync.Mutex
        nextID uint64
        infos  map[EventID]subscriptionInfoList
}

func (bus *bus) Subscribe(eventID EventID, cb EventHandler) Subscription <span class="cov7" title="8">{
        bus.lock.Lock()
        defer bus.lock.Unlock()
        id := bus.nextID
        bus.nextID++
        sub := &amp;subscriptionInfo{
                id: id,
                cb: cb,
        }
        bus.infos[eventID] = append(bus.infos[eventID], sub)
        return Subscription{
                eventID: eventID,
                id:      id,
        }
}</span>

func (bus *bus) Unsubscribe(subscription Subscription) <span class="cov5" title="4">{
        bus.lock.Lock()
        defer bus.lock.Unlock()

        if infos, ok := bus.infos[subscription.eventID]; ok </span><span class="cov5" title="4">{
                for idx, info := range infos </span><span class="cov5" title="4">{
                        if info.id == subscription.id </span><span class="cov5" title="4">{
                                infos = append(infos[:idx], infos[idx+1:]...)
                                break</span>
                        }
                }
                <span class="cov5" title="4">if len(infos) == 0 </span><span class="cov4" title="3">{
                        delete(bus.infos, subscription.eventID)
                }</span> else<span class="cov1" title="1"> {
                        bus.infos[subscription.eventID] = infos
                }</span>
        }
}

func (bus *bus) Publish(event Event) <span class="cov10" title="15">{
        infos := bus.copySubscriptions(event.EventID())
        for _, sub := range infos </span><span class="cov8" title="11">{
                sub.cb(event)
        }</span>
}

func (bus *bus) copySubscriptions(eventID EventID) subscriptionInfoList <span class="cov10" title="15">{
        // External code may subscribe/unsubscribe during iteration over callbacks,
        //  so we need to copy subscribers to invoke callbacks.

        bus.lock.Lock()
        defer bus.lock.Unlock()
        if infos, ok := bus.infos[eventID]; ok </span><span class="cov8" title="10">{
                return infos
        }</span>
        <span class="cov6" title="5">return subscriptionInfoList{}</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package local

import (
        "io/ioutil"
        "os"
        pathutil "path"
        "path/filepath"

        "github.com/krateoplatformops/krateo/pkg/storage"
)

var _ storage.Storage = (*LocalFilesystem)(nil)

// LocalFilesystem is a storage backend for local filesystem storage
type LocalFilesystem struct {
        RootDir string
}

// NewLocalFilesystem creates a new instance of LocalFilesystemBackend
func NewLocalFilesystem(root string) *LocalFilesystem <span class="cov8" title="1">{
        absPath, err := filepath.Abs(root)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">b := &amp;LocalFilesystem{RootDir: absPath}
        return b</span>
}

// List lists all objects in root directory (depth 1)
func (b *LocalFilesystem) List(prefix string) ([]storage.Entry, error) <span class="cov8" title="1">{
        var objects []storage.Entry
        files, err := ioutil.ReadDir(pathutil.Join(b.RootDir, prefix))
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{ // OK if the directory doesnt exist yet
                        err = nil
                }</span>
                <span class="cov8" title="1">return objects, err</span>
        }
        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if f.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">object := storage.Entry{Path: f.Name(), Content: []byte{}, LastModified: f.ModTime()}
                objects = append(objects, object)</span>
        }
        <span class="cov0" title="0">return objects, nil</span>
}

// Get retrieves an object from root directory
func (b *LocalFilesystem) Get(path string) (storage.Entry, error) <span class="cov8" title="1">{
        var object storage.Entry
        object.Path = path
        fullpath := pathutil.Join(b.RootDir, path)
        content, err := ioutil.ReadFile(fullpath)
        if err != nil </span><span class="cov8" title="1">{
                return object, err
        }</span>
        <span class="cov0" title="0">object.Content = content
        info, err := os.Stat(fullpath)
        if err != nil </span><span class="cov0" title="0">{
                return object, err
        }</span>
        <span class="cov0" title="0">object.LastModified = info.ModTime()
        return object, err</span>
}

// PutObject puts an object in root directory
func (b *LocalFilesystem) Put(path string, content []byte) error <span class="cov8" title="1">{
        fullpath := pathutil.Join(b.RootDir, path)
        folderPath := pathutil.Dir(fullpath)
        _, err := os.Stat(folderPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        err := os.MkdirAll(folderPath, 0774)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // os.MkdirAll set the dir permissions before the umask
                        // we need to use os.Chmod to ensure the permissions of the created directory are 774
                        // because the default umask will prevent that and cause the permissions to be 755
                        <span class="cov8" title="1">err = os.Chmod(folderPath, 0774)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">err = ioutil.WriteFile(fullpath, content, 0644)
        return err</span>
}

// DeleteObject removes an object from root directory
func (b *LocalFilesystem) Delete(path string) error <span class="cov0" title="0">{
        fullpath := pathutil.Join(b.RootDir, path)
        err := os.Remove(fullpath)
        return err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright The Helm Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//nolint:errcheck
package strvals

import (
        "bytes"
        "fmt"
        "io"
        "strconv"
        "strings"

        "github.com/pkg/errors"
        "sigs.k8s.io/yaml"
)

// ErrNotList indicates that a non-list was treated as a list.
var ErrNotList = errors.New("not a list")

// ToYAML takes a string of arguments and converts to a YAML document.
func ToYAML(s string) (string, error) <span class="cov1" title="1">{
        m, err := Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">d, err := yaml.Marshal(m)
        return strings.TrimSuffix(string(d), "\n"), err</span>
}

// Parse parses a set line.
//
// A set line is of the form name1=value1,name2=value2
func Parse(s string) (map[string]interface{}, error) <span class="cov5" title="50">{
        vals := map[string]interface{}{}
        scanner := bytes.NewBufferString(s)
        t := newParser(scanner, vals, false)
        err := t.parse()
        return vals, err
}</span>

// ParseString parses a set line and forces a string value.
//
// A set line is of the form name1=value1,name2=value2
func ParseString(s string) (map[string]interface{}, error) <span class="cov2" title="4">{
        vals := map[string]interface{}{}
        scanner := bytes.NewBufferString(s)
        t := newParser(scanner, vals, true)
        err := t.parse()
        return vals, err
}</span>

// ParseInto parses a strvals line and merges the result into dest.
//
// If the strval string has a key that exists in dest, it overwrites the
// dest version.
func ParseInto(s string, dest map[string]interface{}) error <span class="cov3" title="7">{
        scanner := bytes.NewBufferString(s)
        t := newParser(scanner, dest, false)
        return t.parse()
}</span>

// ParseFile parses a set line, but its final value is loaded from the file at the path specified by the original value.
//
// A set line is of the form name1=path1,name2=path2
//
// When the files at path1 and path2 contained "val1" and "val2" respectively, the set line is consumed as
// name1=val1,name2=val2
func ParseFile(s string, reader RunesValueReader) (map[string]interface{}, error) <span class="cov1" title="1">{
        vals := map[string]interface{}{}
        scanner := bytes.NewBufferString(s)
        t := newFileParser(scanner, vals, reader)
        err := t.parse()
        return vals, err
}</span>

// ParseIntoString parses a strvals line and merges the result into dest.
//
// This method always returns a string as the value.
func ParseIntoString(s string, dest map[string]interface{}) error <span class="cov1" title="1">{
        scanner := bytes.NewBufferString(s)
        t := newParser(scanner, dest, true)
        return t.parse()
}</span>

// ParseIntoFile parses a filevals line and merges the result into dest.
//
// This method always returns a string as the value.
func ParseIntoFile(s string, dest map[string]interface{}, reader RunesValueReader) error <span class="cov1" title="1">{
        scanner := bytes.NewBufferString(s)
        t := newFileParser(scanner, dest, reader)
        return t.parse()
}</span>

// RunesValueReader is a function that takes the given value (a slice of runes)
// and returns the parsed value
type RunesValueReader func([]rune) (interface{}, error)

// parser is a simple parser that takes a strvals line and parses it into a
// map representation.
//
// where sc is the source of the original data being parsed
// where data is the final parsed data from the parses with correct types
type parser struct {
        sc     *bytes.Buffer
        data   map[string]interface{}
        reader RunesValueReader
}

func newParser(sc *bytes.Buffer, data map[string]interface{}, stringBool bool) *parser <span class="cov6" title="62">{
        stringConverter := func(rs []rune) (interface{}, error) </span><span class="cov6" title="76">{
                return typedVal(rs, stringBool), nil
        }</span>
        <span class="cov6" title="62">return &amp;parser{sc: sc, data: data, reader: stringConverter}</span>
}

func newFileParser(sc *bytes.Buffer, data map[string]interface{}, reader RunesValueReader) *parser <span class="cov1" title="2">{
        return &amp;parser{sc: sc, data: data, reader: reader}
}</span>

func (t *parser) parse() error <span class="cov6" title="64">{
        for </span><span class="cov7" title="136">{
                err := t.key(t.data)
                if err == nil </span><span class="cov6" title="72">{
                        continue</span>
                }
                <span class="cov6" title="64">if err == io.EOF </span><span class="cov5" title="50">{
                        return nil
                }</span>
                <span class="cov4" title="14">return err</span>
        }
}

func runeSet(r []rune) map[rune]bool <span class="cov8" title="326">{
        s := make(map[rune]bool, len(r))
        for _, rr := range r </span><span class="cov9" title="934">{
                s[rr] = true
        }</span>
        <span class="cov8" title="326">return s</span>
}

func (t *parser) key(data map[string]interface{}) (reterr error) <span class="cov7" title="175">{
        defer func() </span><span class="cov7" title="175">{
                if r := recover(); r != nil </span><span class="cov1" title="1">{
                        reterr = fmt.Errorf("unable to parse key: %s", r)
                }</span>
        }()
        <span class="cov7" title="175">stop := runeSet([]rune{'=', '[', ',', '.'})
        for </span><span class="cov7" title="175">{
                switch k, last, err := runesUntil(t.sc, stop); </span>{
                case err != nil:<span class="cov5" title="49">
                        if len(k) == 0 </span><span class="cov5" title="48">{
                                return err
                        }</span>
                        <span class="cov1" title="1">return errors.Errorf("key %q has no value", string(k))</span>
                        //set(data, string(k), "")
                        //return err
                case last == '[':<span class="cov5" title="30">
                        // We are in a list index context, so we need to set an index.
                        i, err := t.keyIndex()
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "error parsing index")
                        }</span>
                        <span class="cov5" title="30">kk := string(k)
                        // Find or create target list
                        list := []interface{}{}
                        if _, ok := data[kk]; ok </span><span class="cov4" title="12">{
                                list = data[kk].([]interface{})
                        }</span>

                        // Now we need to get the value after the ].
                        <span class="cov5" title="30">list, err = t.listItem(list, i)
                        set(data, kk, list)
                        return err</span>
                case last == '=':<span class="cov6" title="64">
                        //End of key. Consume =, Get value.
                        // FIXME: Get value list first
                        vl, e := t.valList()
                        switch e </span>{
                        case nil:<span class="cov3" title="6">
                                set(data, string(k), vl)
                                return nil</span>
                        case io.EOF:<span class="cov1" title="1">
                                set(data, string(k), "")
                                return e</span>
                        case ErrNotList:<span class="cov5" title="56">
                                rs, e := t.val()
                                if e != nil &amp;&amp; e != io.EOF </span><span class="cov0" title="0">{
                                        return e
                                }</span>
                                <span class="cov5" title="56">v, e := t.reader(rs)
                                set(data, string(k), v)
                                return e</span>
                        default:<span class="cov1" title="1">
                                return e</span>
                        }

                case last == ',':<span class="cov3" title="7">
                        // No value given. Set the value to empty string. Return error.
                        set(data, string(k), "")
                        return errors.Errorf("key %q has no value (cannot end with ,)", string(k))</span>
                case last == '.':<span class="cov4" title="25">
                        // First, create or find the target map.
                        inner := map[string]interface{}{}
                        if _, ok := data[string(k)]; ok </span><span class="cov3" title="10">{
                                inner = data[string(k)].(map[string]interface{})
                        }</span>

                        // Recurse
                        <span class="cov4" title="24">e := t.key(inner)
                        if len(inner) == 0 </span><span class="cov2" title="3">{
                                return errors.Errorf("key map %q has no value", string(k))
                        }</span>
                        <span class="cov4" title="21">set(data, string(k), inner)
                        return e</span>
                }
        }
}

func set(data map[string]interface{}, key string, val interface{}) <span class="cov6" title="121">{
        // If key is empty, don't set it.
        if len(key) == 0 </span><span class="cov2" title="3">{
                return
        }</span>
        <span class="cov6" title="118">data[key] = val</span>
}

func setIndex(list []interface{}, index int, val interface{}) (l2 []interface{}, err error) <span class="cov5" title="40">{
        // There are possible index values that are out of range on a target system
        // causing a panic. This will catch the panic and return an error instead.
        // The value of the index that causes a panic varies from system to system.
        defer func() </span><span class="cov5" title="40">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("error processing index %d: %s", index, r)
                }</span>
        }()

        <span class="cov5" title="40">if index &lt; 0 </span><span class="cov1" title="1">{
                return list, fmt.Errorf("negative %d index not allowed", index)
        }</span>
        <span class="cov5" title="39">if len(list) &lt;= index </span><span class="cov5" title="30">{
                newlist := make([]interface{}, index+1)
                copy(newlist, list)
                list = newlist
        }</span>
        <span class="cov5" title="39">list[index] = val
        return list, nil</span>
}

func (t *parser) keyIndex() (int, error) <span class="cov5" title="40">{
        // First, get the key.
        stop := runeSet([]rune{']'})
        v, _, err := runesUntil(t.sc, stop)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        // v should be the index
        <span class="cov5" title="40">return strconv.Atoi(string(v))</span>

}
func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) <span class="cov5" title="40">{
        if i &lt; 0 </span><span class="cov1" title="2">{
                return list, fmt.Errorf("negative %d index not allowed", i)
        }</span>
        <span class="cov5" title="38">stop := runeSet([]rune{'[', '.', '='})
        switch k, last, err := runesUntil(t.sc, stop); </span>{
        case len(k) &gt; 0:<span class="cov1" title="1">
                return list, errors.Errorf("unexpected data at end of array index: %q", k)</span>
        case err != nil:<span class="cov1" title="1">
                return list, err</span>
        case last == '=':<span class="cov3" title="11">
                vl, e := t.valList()
                switch e </span>{
                case nil:<span class="cov0" title="0">
                        return setIndex(list, i, vl)</span>
                case io.EOF:<span class="cov1" title="1">
                        return setIndex(list, i, "")</span>
                case ErrNotList:<span class="cov3" title="10">
                        rs, e := t.val()
                        if e != nil &amp;&amp; e != io.EOF </span><span class="cov0" title="0">{
                                return list, e
                        }</span>
                        <span class="cov3" title="10">v, e := t.reader(rs)
                        if e != nil </span><span class="cov0" title="0">{
                                return list, e
                        }</span>
                        <span class="cov3" title="10">return setIndex(list, i, v)</span>
                default:<span class="cov0" title="0">
                        return list, e</span>
                }
        case last == '[':<span class="cov3" title="10">
                // now we have a nested list. Read the index and handle.
                nextI, err := t.keyIndex()
                if err != nil </span><span class="cov0" title="0">{
                        return list, errors.Wrap(err, "error parsing index")
                }</span>
                <span class="cov3" title="10">var crtList []interface{}
                if len(list) &gt; i </span><span class="cov2" title="4">{
                        // If nested list already exists, take the value of list to next cycle.
                        existed := list[i]
                        if existed != nil </span><span class="cov2" title="4">{
                                crtList = list[i].([]interface{})
                        }</span>
                }
                // Now we need to get the value after the ].
                <span class="cov3" title="10">list2, err := t.listItem(crtList, nextI)
                if err != nil </span><span class="cov0" title="0">{
                        return list, err
                }</span>
                <span class="cov3" title="10">return setIndex(list, i, list2)</span>
        case last == '.':<span class="cov4" title="15">
                // We have a nested object. Send to t.key
                inner := map[string]interface{}{}
                if len(list) &gt; i </span><span class="cov2" title="3">{
                        var ok bool
                        inner, ok = list[i].(map[string]interface{})
                        if !ok </span><span class="cov1" title="1">{
                                // We have indices out of order. Initialize empty value.
                                list[i] = map[string]interface{}{}
                                inner = list[i].(map[string]interface{})
                        }</span>
                }

                // Recurse
                <span class="cov4" title="15">e := t.key(inner)
                if e != nil </span><span class="cov0" title="0">{
                        return list, e
                }</span>
                <span class="cov4" title="15">return setIndex(list, i, inner)</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("parse error: unexpected token %v", last)</span>
        }
}

func (t *parser) val() ([]rune, error) <span class="cov6" title="66">{
        stop := runeSet([]rune{','})
        v, _, err := runesUntil(t.sc, stop)
        return v, err
}</span>

func (t *parser) valList() ([]interface{}, error) <span class="cov6" title="75">{
        r, _, e := t.sc.ReadRune()
        if e != nil </span><span class="cov1" title="2">{
                return []interface{}{}, e
        }</span>

        <span class="cov6" title="73">if r != '{' </span><span class="cov6" title="66">{
                t.sc.UnreadRune()
                return []interface{}{}, ErrNotList
        }</span>

        <span class="cov3" title="7">list := []interface{}{}
        stop := runeSet([]rune{',', '}'})
        for </span><span class="cov4" title="13">{
                switch rs, last, err := runesUntil(t.sc, stop); </span>{
                case err != nil:<span class="cov1" title="1">
                        if err == io.EOF </span><span class="cov1" title="1">{
                                err = errors.New("list must terminate with '}'")
                        }</span>
                        <span class="cov1" title="1">return list, err</span>
                case last == '}':<span class="cov3" title="6">
                        // If this is followed by ',', consume it.
                        if r, _, e := t.sc.ReadRune(); e == nil &amp;&amp; r != ',' </span><span class="cov1" title="1">{
                                t.sc.UnreadRune()
                        }</span>
                        <span class="cov3" title="6">v, e := t.reader(rs)
                        list = append(list, v)
                        return list, e</span>
                case last == ',':<span class="cov3" title="6">
                        v, e := t.reader(rs)
                        if e != nil </span><span class="cov0" title="0">{
                                return list, e
                        }</span>
                        <span class="cov3" title="6">list = append(list, v)</span>
                }
        }
}

func runesUntil(in io.RuneReader, stop map[rune]bool) ([]rune, rune, error) <span class="cov8" title="332">{
        v := []rune{}
        for </span><span class="cov10" title="1405">{
                switch r, _, e := in.ReadRune(); </span>{
                case e != nil:<span class="cov6" title="93">
                        return v, r, e</span>
                case inMap(r, stop):<span class="cov7" title="239">
                        return v, r, nil</span>
                case r == '\\':<span class="cov2" title="4">
                        next, _, e := in.ReadRune()
                        if e != nil </span><span class="cov0" title="0">{
                                return v, next, e
                        }</span>
                        <span class="cov2" title="4">v = append(v, next)</span>
                default:<span class="cov9" title="1069">
                        v = append(v, r)</span>
                }
        }
}

func inMap(k rune, m map[rune]bool) bool <span class="cov9" title="1312">{
        _, ok := m[k]
        return ok
}</span>

func typedVal(v []rune, st bool) interface{} <span class="cov6" title="76">{
        val := string(v)

        if st </span><span class="cov3" title="6">{
                return val
        }</span>

        <span class="cov6" title="70">if strings.EqualFold(val, "true") </span><span class="cov1" title="2">{
                return true
        }</span>

        <span class="cov6" title="68">if strings.EqualFold(val, "false") </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov6" title="67">if strings.EqualFold(val, "null") </span><span class="cov1" title="2">{
                return nil
        }</span>

        <span class="cov6" title="65">if strings.EqualFold(val, "0") </span><span class="cov1" title="1">{
                return int64(0)
        }</span>

        // If this value does not start with zero, try parsing it to an int
        <span class="cov6" title="64">if len(val) != 0 &amp;&amp; val[0] != '0' </span><span class="cov6" title="61">{
                if iv, err := strconv.ParseInt(val, 10, 64); err == nil </span><span class="cov3" title="7">{
                        return iv
                }</span>
        }

        <span class="cov6" title="57">return val</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package xrds

import (
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "sigs.k8s.io/yaml"
)

// Field is a property in the composite resource definition
type Field struct {
        Name        string
        Description string
        Type        string
        Default     string
        Required    bool
}

func ParseCompositeResourceDefinition(xrd *CompositeResourceDefinition) ([]Field, error) <span class="cov2" title="2">{
        p := &amp;parser{
                fields: make([]Field, 0),
        }

        return p.parse(xrd)
}</span>

func ParseBytes(dat []byte) ([]Field, error) <span class="cov2" title="2">{
        xrd := &amp;CompositeResourceDefinition{}
        err := yaml.Unmarshal(dat, xrd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">return ParseCompositeResourceDefinition(xrd)</span>
}

type parser struct {
        fields []Field
}

func (p *parser) parse(src *CompositeResourceDefinition) ([]Field, error) <span class="cov2" title="2">{
        if len(src.Spec.Versions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no spec version found")
        }</span>

        <span class="cov2" title="2">defs := src.Spec.Versions[0].Schema.OpenAPIV3Schema
        if defs == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("openapi schema not found")
        }</span>

        <span class="cov2" title="2">spec, ok := defs.Properties["spec"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missed 'spec' in openapi schema")
        }</span>

        <span class="cov2" title="2">err := p.parseObject(spec, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">for i, el := range p.fields </span><span class="cov7" title="62">{
                if contains(defs.Required, el.Name) </span><span class="cov3" title="4">{
                        p.fields[i].Required = true
                }</span>
        }

        <span class="cov2" title="2">sort.Slice(p.fields, func(i, j int) bool </span><span class="cov10" title="247">{
                return p.fields[i].Name &lt; p.fields[j].Name
        }</span>)

        <span class="cov2" title="2">return p.fields, nil</span>
}

func (p *parser) parseArray(el JSONSchemaProps, prefix string) error <span class="cov3" title="4">{
        var props JSONSchemaProps
        err := json.Unmarshal(el.Items.RawMessage, &amp;props)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="4">return p.parseObject(props, fmt.Sprintf("%s[0]", prefix))</span>
}

func (p *parser) parseObject(el JSONSchemaProps, prefix string) error <span class="cov7" title="44">{
        for key, val := range el.Properties </span><span class="cov8" title="104">{
                name := strings.ReplaceAll(key, ".", "\\.")
                if len(prefix) &gt; 0 </span><span class="cov7" title="72">{
                        name = fmt.Sprintf("%s.%s", prefix, name)
                }</span>

                <span class="cov8" title="104">switch val.Type </span>{
                case TypeObject:<span class="cov6" title="38">
                        err := p.parseObject(val, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case TypeArray:<span class="cov3" title="4">
                        err := p.parseArray(val, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov7" title="62">
                        item := Field{
                                Name:        name,
                                Description: val.Description,
                                Type:        val.Type,
                                Required:    contains(el.Required, key),
                        }

                        if val.Default != nil </span><span class="cov5" title="12">{
                                item.Default = val.Default.String()
                        }</span>

                        <span class="cov7" title="62">p.fields = append(p.fields, item)</span>
                }
        }

        <span class="cov7" title="44">return nil</span>
}

func contains(elems []string, v string) bool <span class="cov8" title="124">{
        for _, s := range elems </span><span class="cov8" title="122">{
                if v == s </span><span class="cov3" title="4">{
                        return true
                }</span>
        }
        <span class="cov8" title="120">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package xrds

import "encoding/json"

const (
        TypeArray   = "array"
        TypeBoolean = "boolean"
        TypeInteger = "integer"
        TypeNumber  = "number"
        TypeObject  = "object"
        TypeString  = "string"
)

type JSONSchemaProps struct {
        Description string `json:"description,omitempty"`
        Type        string `json:"type,omitempty"`

        // format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated:
        //
        // - bsonobjectid: a bson object ID, i.e. a 24 characters hex string
        // - uri: an URI as parsed by Golang net/url.ParseRequestURI
        // - email: an email address as parsed by Golang net/mail.ParseAddress
        // - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].
        // - ipv4: an IPv4 IP as parsed by Golang net.ParseIP
        // - ipv6: an IPv6 IP as parsed by Golang net.ParseIP
        // - cidr: a CIDR as parsed by Golang net.ParseCIDR
        // - mac: a MAC address as parsed by Golang net.ParseMAC
        // - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$
        // - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$
        // - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$
        // - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$
        // - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041"
        // - isbn10: an ISBN10 number string like "0321751043"
        // - isbn13: an ISBN13 number string like "978-0321751041"
        // - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in
        // - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$
        // - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$
        // - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559"
        // - byte: base64 encoded binary data
        // - password: any kind of string
        // - date: a date string like "2006-01-02" as defined by full-date in RFC3339
        // - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format
        // - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        Format string `json:"format,omitempty"`

        Default *JSON `json:"default,omitempty"`

        Title string `json:"title,omitempty"`

        Enum       []JSON                     `json:"enum,omitempty"`
        Required   []string                   `json:"required,omitempty"`
        Items      JSON                       `json:"items,omitempty"`
        Properties map[string]JSONSchemaProps `json:"properties,omitempty"`
}

// JSON represents any valid JSON value.
// These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
type JSON struct {
        json.RawMessage `json:"raw,omitempty"`
}

func (j *JSON) String() string <span class="cov10" title="12">{
        s := string(j.RawMessage)
        if len(s) &gt;= 2 </span><span class="cov10" title="12">{
                if s[0] == '"' &amp;&amp; s[len(s)-1] == '"' </span><span class="cov7" title="6">{
                        return s[1 : len(s)-1]
                }</span>
        }
        <span class="cov7" title="6">return s</span>
}

// JSON represents any valid JSON value.
// These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
//type JSON struct {
//        Raw []byte `json:"raw,omitempty"`
//}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
